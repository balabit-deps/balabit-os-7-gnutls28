From e14d85eb8b1987d86f7b1d101a0e7795675d20d4 Mon Sep 17 00:00:00 2001
From: Nikos Mavrogiannopoulos <nmav@redhat.com>
Date: Tue, 12 Jun 2018 14:22:52 +0200
Subject: [PATCH] dummy_wait: correctly account the length field in SHA384 HMAC

The existing lucky13 attack count-measures did not work correctly for
SHA384 HMAC.

The overall impact of that should not be significant as SHA384 is prioritized
lower than SHA256 or SHA1 and thus it is not typically negotiated, unless a
client prioritizes a SHA384 MAC, or a server only supports SHA384, and in both
cases the vulnerability is only present if Encrypt-then-MAC (RFC7366) is unsupported
by the peer.

Relates #455

Signed-off-by: Nikos Mavrogiannopoulos <nmav@redhat.com>
---
 lib/algorithms/mac.c |  4 ++--
 lib/cipher.c         | 24 +++++++++++-------------
 2 files changed, 13 insertions(+), 15 deletions(-)

diff --git a/lib/algorithms/mac.c b/lib/algorithms/mac.c
index 0198e4a205..d345ddb712 100644
--- a/lib/algorithms/mac.c
+++ b/lib/algorithms/mac.c
@@ -37,9 +37,9 @@ static const mac_entry_st hash_algorithms[] = {
 	{"SHA256", HASH_OID_SHA256, MAC_OID_SHA256, GNUTLS_MAC_SHA256, 32, 32, 0, 0, 1,
 	 64},
 	{"SHA384", HASH_OID_SHA384, MAC_OID_SHA384, GNUTLS_MAC_SHA384, 48, 48, 0, 0, 1,
-	 64},
+	 128},
 	{"SHA512", HASH_OID_SHA512, MAC_OID_SHA512, GNUTLS_MAC_SHA512, 64, 64, 0, 0, 1,
-	 64},
+	 128},
 	{"SHA224", HASH_OID_SHA224, MAC_OID_SHA224, GNUTLS_MAC_SHA224, 28, 28, 0, 0, 1,
 	 64},
 	{"SHA3-256", HASH_OID_SHA3_256, NULL, GNUTLS_MAC_SHA3_256, 32, 32, 0, 0, 1,
diff --git a/lib/cipher.c b/lib/cipher.c
index 84f30637be..c675a64032 100644
--- a/lib/cipher.c
+++ b/lib/cipher.c
@@ -459,9 +459,10 @@ static void dummy_wait(record_parameters_st * params,
 		       gnutls_datum_t * plaintext, unsigned pad_failed,
 		       unsigned int pad, unsigned total)
 {
-	/* this hack is only needed on CBC ciphers */
+	/* this hack is only needed on CBC ciphers when Encrypt-then-MAC mode
+	 * is not supported by the peer. */
 	if (_gnutls_cipher_type(params->cipher) == CIPHER_BLOCK) {
-		unsigned len;
+		unsigned len, v;
 
 		/* force an additional hash compression function evaluation to prevent timing 
 		 * attacks that distinguish between wrong-mac + correct pad, from wrong-mac + incorrect pad.
@@ -469,11 +470,14 @@ static void dummy_wait(record_parameters_st * params,
 		if (pad_failed == 0 && pad > 0) {
 			len = _gnutls_mac_block_size(params->mac);
 			if (len > 0) {
-				/* This is really specific to the current hash functions.
-				 * It should be removed once a protocol fix is in place.
-				 */
-				if ((pad + total) % len > len - 9
-				    && total % len <= len - 9) {
+				if (params->mac && params->mac->id == GNUTLS_MAC_SHA384)
+					/* v = 1 for the hash function padding + 16 for message length */
+					v = 17;
+				else /* v = 1 for the hash function padding + 8 for message length */
+					v = 9;
+
+				if ((pad + total) % len > len - v
+				    && total % len <= len - v) {
 					if (len < plaintext->size)
 						_gnutls_auth_cipher_add_auth
 						    (&params->read.
@@ -814,12 +818,6 @@ ciphertext_to_compressed(gnutls_session_t session,
 		if (unlikely(ret < 0))
 			return gnutls_assert_val(ret);
 
-		/* Here there could be a timing leakage in CBC ciphersuites that
-		 * could be exploited if the cost of a successful memcmp is high. 
-		 * A constant time memcmp would help there, but it is not easy to maintain
-		 * against compiler optimizations. Currently we rely on the fact that
-		 * a memcmp comparison is negligible over the crypto operations.
-		 */
 		if (unlikely
 		    (gnutls_memcmp(tag, tag_ptr, tag_size) != 0 || pad_failed != 0)) {
 			/* HMAC was not the same. */
-- 
2.21.0

